#ifndef CPU_H
#define CPU_H

#include <array>
#include <cstdint>
#include <iostream>
#include <vector>

// ğŸ¯ æŒ‡ä»¤æ“ä½œç æšä¸¾ï¼šå®šä¹‰æ”¯æŒçš„RISC-VæŒ‡ä»¤ç±»å‹
enum class OpCode : uint8_t {
  ADDI = 0x13,  // â• ç«‹å³æ•°åŠ æ³•æŒ‡ä»¤
  ADD = 0x33,   // â• å¯„å­˜å™¨åŠ æ³•æŒ‡ä»¤
  // ğŸ”„ åç»­å¯ä»¥è½»æ¾æ·»åŠ æ›´å¤šæŒ‡ä»¤
};

// ğŸ” æŒ‡ä»¤å­—æ®µç»“æ„ä½“ï¼šå­˜å‚¨è§£ç åçš„æŒ‡ä»¤å„ä¸ªå­—æ®µ
struct InstructionFields {
  OpCode opcode;   // ğŸ“ æ“ä½œç ï¼šæ ‡è¯†æŒ‡ä»¤ç±»å‹
  uint8_t rd;      // ğŸ“¥ ç›®æ ‡å¯„å­˜å™¨
  uint8_t rs1;     // ğŸ“¤ æºå¯„å­˜å™¨1
  uint8_t rs2;     // ğŸ“¤ æºå¯„å­˜å™¨2
  uint8_t funct3;  // ğŸ”§ åŠŸèƒ½ç 3ï¼šè¿›ä¸€æ­¥ç»†åˆ†æŒ‡ä»¤åŠŸèƒ½
  uint8_t funct7;  // ğŸ”§ åŠŸèƒ½ç 7ï¼šç”¨äºåŒºåˆ†ç›¸åŒæ“ä½œç çš„ä¸åŒæŒ‡ä»¤
  int32_t i_imm;  // ğŸ’« ç«‹å³æ•°ï¼šæŒ‡ä»¤ä¸­çš„å¸¸é‡å€¼
};

// ğŸ–¥ï¸ CPUæ¨¡æ‹Ÿå™¨ç»“æ„ä½“ï¼šæ¨¡æ‹ŸRISC-Vå¤„ç†å™¨çš„æ ¸å¿ƒç»„ä»¶
struct Cpu {
  std::array<uint64_t, 32> regs{};  // ğŸ§  32ä¸ªé€šç”¨å¯„å­˜å™¨ï¼ˆx0-x31ï¼‰
  uint64_t pc = 0;  // ğŸ“ ç¨‹åºè®¡æ•°å™¨ï¼šæŒ‡å‘å½“å‰æ‰§è¡Œçš„æŒ‡ä»¤
  std::vector<uint8_t> mem;  // ğŸ’¾ æ¨¡æ‹Ÿå†…å­˜ï¼šå­˜å‚¨ç¨‹åºå’Œæ•°æ®

  // ğŸ—ï¸ æ„é€ å‡½æ•°ï¼šåˆå§‹åŒ–CPUçŠ¶æ€å’ŒåŠ è½½ç¨‹åº
  explicit Cpu(const std::vector<uint8_t>& code);

  // ğŸ¯ å–æŒ‡é˜¶æ®µï¼šä»å†…å­˜ä¸­è¯»å–å½“å‰æŒ‡ä»¤
  uint32_t fetch();

  // âš¡ æ‰§è¡Œé˜¶æ®µï¼šå¤„ç†å½“å‰æŒ‡ä»¤å¹¶æ›´æ–°CPUçŠ¶æ€
  void execute(uint32_t instr);

  // ğŸ” è°ƒè¯•åŠŸèƒ½ï¼šè¾“å‡ºCPUå½“å‰çŠ¶æ€ä¿¡æ¯
  void debug();

 private:
  // ğŸ”„ æŒ‡ä»¤è§£ç ï¼šå°†32ä½æŒ‡ä»¤è§£æä¸ºå„ä¸ªåŠŸèƒ½å­—æ®µ
  static InstructionFields decode_instruction(uint32_t instr);
};

#endif  // CPU_H